[{"content":"Introduction Whenever I want to start a new Python project, I used to go for the standard venv included with Python. But, I easily got rid of it, since the folder it creates makes my editor too clumsy.\nAfterwards, I discovered Pipenv and I was very happy with it, until I figured out that it doesn\u0026rsquo;t work well with some packages (e.g. colorama), since it specifies the platform type in the Pipfile.lock file, that I always add to my .gitignore file. Recently I looked for a solution to this cross-platform issue, that\u0026rsquo;s when I found out that people are suggesting using Poetry, a tool which I already heard about, but never took time to give it a chance.\nI finally gave Poetry a chance that day, and from that point, Poetry became my best friend.\nIn my first blog post, I\u0026rsquo;ll take you through my Python Setup.\nPoetry Installing poetry  Poetry is a Python packaging and dependency management tool that assists you during the entire development process, from installing dependencies, code packaging, to publishing your code.\n Powershell (Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python - Bash curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python -  Verify that the installation was successful by running poetry --version.\n Poetry lifecycle 1. Project setup poetry new blueprint The above command will ask you for meta infos related to the project (version, authors, license\u0026hellip;), then a new directory will be created with the following content:\nblueprint â”œâ”€â”€ pyproject.toml # contains dependencies, project metadata and more â”œâ”€â”€ README.rst â”œâ”€â”€ blueprint â”‚ â””â”€â”€ __init__.py â””â”€â”€ tests â”œâ”€â”€ __init__.py â””â”€â”€ test_blueprint.py 2. Add dependencies In order to install a dependency, you need to run the following command:\npoetry add \u0026lt;package\u0026gt; If you\u0026rsquo;d like to add the dependency as a dev dependency, you can use the --dev (-D) flag:\npoetry add -D \u0026lt;dev-package\u0026gt; 3. Export requirements.txt file This command generates a requirements.txt file containing all the dependencies you\u0026rsquo;ve added to your project.\npoetry export -f requirements.txt --output requirements.txt If you want to export the dev dependencies too, you can use the --dev flag:\npoetry export -f requirements.txt --dev --output requirements_dev.txt Poe the Poet Poe is a task runner plugin that runs with Poetry, allowing you to run tasks in Poetry\u0026rsquo;s virtual environment. It can be added to projects using different ways, but I prefer adding it a dev dependency.\npoetry add --dev poethepoet Tasks are defined withing the pyproject.toml file:\n# pyproject.toml [tool.poe.tasks] [tool.poe.tasks.format] help = \u0026#34;Run black on the code base\u0026#34; cmd = \u0026#34;black .\u0026#34; And can be run using the following command:\npoe format # or `poetry run poe format` if outside poetry shell Code Editor My editor of choice is Visual Studio Code and I use it to develop all my projects.\nThis is a list of the Python related extensions I use in my editor:\n Python\u0026rsquo;s official extension: Includes IntelliSense using Pylance, Linting, Jupyter Notebooks, code formatting, refactoring, unit tests \u0026hellip; Python Test Explorer: I\u0026rsquo;ve been struggling with unit tests discovery on Windows, and this extension helps me to run them. Python Environment Manager: This extension gives a full overview on Python environments. autoDocstring: This extension helps me to generate docstrings for my code, all I have to do is type \u0026quot;\u0026quot;\u0026quot; and the extension will generate the docstring for me. Sourcery: An awesome Python refactoring tool. Tabnine and GitHub Copilot: Cause who doesn\u0026rsquo;t like AI writing code for them?  Code formatting and linting For code formatting, I use black and for linting, I use flake8 or pylint.\nUnit testing I admit it, I rarely write tests for my code (cause my code never fails ðŸ˜Ž), but on serious projects I use pytest with pytest-cov for code coverage, plus pytest-mock mocking fixtures.\nWith poe, I can run tests with coverage using the following command:\npoe test # pyproject.toml [tool.poe.tasks] [tool.poe.tasks.test] help = \u0026#34;Run pytest on the code base\u0026#34; cmd = \u0026#34;pytest -v --cov=src --cov-report=term\u0026#34; Pre-commit hooks Before publishing my code to GitHub, I always have to re-check my code for linting, formatting, security issues\u0026hellip; and I use pre-commit to do that.\nIt can be installed using the following command:\npoetry add --dev pre-commit Here\u0026rsquo;s a sample of the .pre-commit-config.yaml configuration file:\n# .pre-commit-config.yamlrepos:- repo:https://github.com/pre-commit/pre-commit-hooksrev:v2.3.0hooks:- id:check-yaml- id:end-of-file-fixer- id:trailing-whitespace- id:check-added-large-files- id:detect-private-key- repo:https://github.com/psf/blackrev:22.1.0hooks:- id:blacklanguage_version:python3.8- repo:https://gitlab.com/pycqa/flake8rev:3.7.9hooks:- id:flake8GitHub actions The entire pipeline of my projects is managed by GitHub Actions, here\u0026rsquo;s the CIconfiguration for my projects:\nname:Check Codeon:push:branches:[main ]# on push to mainpaths-ignore:- \u0026#39;*.md\u0026#39;# ignore .md files changespull_request:branches:[main ]# on pull requests to mainpaths-ignore:- \u0026#39;*.md\u0026#39;# ignore .md files changesjobs:ci:strategy:max-parallel:2matrix:python-version:[3.8,3.9]poetry-version:[1.1.13]os:[ubuntu-latest, macos-latest, windows-latest]runs-on:${{ matrix.os }}timeout-minutes:10steps:- name:Check out repository codeuses:actions/checkout@v2# Setup Python (faster than using Python container)- name:Setup Python ${{ matrix.python-version }} on ${{ matrix.os }}uses:actions/setup-python@v2with:python-version:${{ matrix.python-version }}- name:Install wheelrun:python -m pip install wheel- name:Install poetry ${{ matrix.poetry-version }}uses:abatilo/actions-poetry@v2.0.0with:poetry-version:${{ matrix.poetry-version }}- name:Cache Poetry virtualenvuses:actions/cache@v2id:cachewith:path:~/.virtualenvskey:poetry-${{ hashFiles(\u0026#39;**/poetry.lock\u0026#39;) }}-py${{ matrix.python-version }}-os${{ matrix.os }}restore-keys:|poetry-${{ hashFiles(\u0026#39;**/poetry.lock\u0026#39;) }}-py${{ matrix.python-version }}-os${{ matrix.os }}- name:Config Poetryrun:|poetry config virtualenvs.in-project false poetry config virtualenvs.path ~/.virtualenvs- name:Install Dependencies using Poetryrun:poetry installif:steps.cache.outputs.cache-hit != \u0026#39;true\u0026#39;- name:Check for security issuesrun:poetry run poe bandit- name:Run test suiterun:poetry run poe testConclusion There are many libraries and tools that can be added to the list such as bandit, autoflake, make, Docker, etc. But I\u0026rsquo;ll let those for another day.\nI made a GitHub repo that I use as a template for my Python projects, give it a try and let me know what you think!\nFinally, I\u0026rsquo;d like to wish you all Ramadan Mubarak! Hope you liked my first blog post!\n","permalink":"https://aymane11.github.io/posts/setup-python-environment/","summary":"Introduction Whenever I want to start a new Python project, I used to go for the standard venv included with Python. But, I easily got rid of it, since the folder it creates makes my editor too clumsy.\nAfterwards, I discovered Pipenv and I was very happy with it, until I figured out that it doesn\u0026rsquo;t work well with some packages (e.g. colorama), since it specifies the platform type in the Pipfile.","title":"Setup Python Environment"}]